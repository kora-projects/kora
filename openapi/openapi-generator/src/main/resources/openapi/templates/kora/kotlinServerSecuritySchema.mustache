/**
 * NOTE: This class is auto generated by Kora OpenAPI Generator (https://openapi-generator.tech) ({{{generatorVersion}}}).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package {{apiPackage}}

import java.util.function.Function

import ru.tinkoff.kora.common.Context
import ru.tinkoff.kora.common.Module
import ru.tinkoff.kora.common.Tag
import ru.tinkoff.kora.common.DefaultComponent
import ru.tinkoff.kora.common.Principal
import ru.tinkoff.kora.config.common.extractor.ConfigValueExtractor
import ru.tinkoff.kora.config.common.Config
import ru.tinkoff.kora.http.server.common.HttpServerInterceptor
import ru.tinkoff.kora.http.server.common.HttpServerInterceptor.InterceptChain
import ru.tinkoff.kora.http.server.common.HttpServerRequest
import ru.tinkoff.kora.http.server.common.HttpServerResponse
import ru.tinkoff.kora.http.server.common.HttpServerResponseException
import java.util.concurrent.CompletionStage
import java.util.concurrent.CompletableFuture
import java.util.concurrent.CompletionException


import ru.tinkoff.kora.http.common.auth.*
import ru.tinkoff.kora.http.server.common.auth.*



@ru.tinkoff.kora.common.annotation.Generated("openapi generator kora client")
@ru.tinkoff.kora.common.Module
public interface ApiSecurity {
{{#vendorExtensions.tags}}

    class {{.}} {}
{{/vendorExtensions.tags}}

{{#vendorExtensions.authMethods}}
    @ru.tinkoff.kora.common.annotation.Generated("openapi generator kora server")
    class {{name}}HttpServerInterceptor(
        {{#methods}}  @Tag(ApiSecurity.{{#lambda.classname}}{{name}}{{/lambda.classname}}::class) val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}: HttpServerPrincipalExtractor<{{#isOAuth}}PrincipalWithScopes{{/isOAuth}}{{^isOAuth}}Principal{{/isOAuth}}>{{^vendorExtensions.isLast}},
        {{/vendorExtensions.isLast}}{{/methods}}
    ) : HttpServerInterceptor {

        override fun intercept(ctx: Context, request: HttpServerRequest, chain: InterceptChain): CompletionStage<HttpServerResponse> {
            val future = CompletableFuture<Principal>()
            {{#methods}}{{#vendorExtensions.isFirst}}{{#isApiKey}}{{#isKeyInHeader}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("{{keyParamName}}"){{/isKeyInHeader}}{{#isKeyInQuery}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query = request.queryParams().get("{{keyParamName}}")
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query == null || {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query.isEmpty()
            ? null
            : {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query.iterator().next(){{/isKeyInQuery}}{{#isKeyInCookie}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.cookies().stream().filter(c -> "{{keyParamName}}".equals(c.name())).map(c -> c.value()).findFirst().orElse(null)
            {{/isKeyInCookie}}
            {{/isApiKey}}{{#isBasicBasic}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization"){{/isBasicBasic}}{{#isBasicBearer}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization"){{/isBasicBearer}}{{#isOAuth}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization"){{/isOAuth}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}} = this.{{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}.extract(request, {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token){{^isOAuth}}{{/isOAuth}}{{#isOAuth}}{{#vendorExtensions.hasScopes}}
            .thenCompose<Principal> { principal ->
                {{#scopes}}{{#-first}}if{{/-first}}{{^-first}} else if{{/-first}} (!principal.scopes().contains("{{scope}}")) {
                    CompletableFuture.failedFuture(HttpServerResponseException.of(403, "Forbidden"))
                }{{/scopes}} else {
                    CompletableFuture.completedFuture(principal)
                }
            }{{/vendorExtensions.hasScopes}}{{/isOAuth}}

            {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}.whenComplete { {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal, {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error ->
                if ({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error != null) {
                    future.completeExceptionally({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error)
                } else if ({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal != null) {
                    future.complete({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal)
                } else {
            {{#vendorExtensions.isLast}}
                    future.completeExceptionally(HttpServerResponseException.of(403, "Forbidden"))
            {{/vendorExtensions.isLast}}
            {{/vendorExtensions.isFirst}}{{/methods}}{{#methods}}{{^vendorExtensions.isFirst}}{{#lambda.indented}}{{#isApiKey}}{{#isKeyInHeader}}
                    val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("{{keyParamName}}"){{/isKeyInHeader}}{{#isKeyInQuery}}
                    val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query = request.queryParams().get("{{keyParamName}}")
                    val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query == null || {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query.isEmpty()
                    ? null
                    : {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query.iterator().next(){{/isKeyInQuery}}{{#isKeyInCookie}}
                    val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.cookies().stream().filter(c -> "{{keyParamName}}".equals(c.name())).map(c -> c.value()).findFirst().orElse(null){{/isKeyInCookie}}{{/isApiKey}}{{#isBasicBasic}}
                    val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization"){{/isBasicBasic}}{{#isBasicBearer}}
                    val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization"){{/isBasicBearer}}{{#isOAuth}}
                    val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization"){{/isOAuth}}
                    val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}} = this.{{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}.extract(request, {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token){{^isOAuth}}{{/isOAuth}}{{#isOAuth}}{{#vendorExtensions.hasScopes}}
                        .thenCompose<Principal> { principal ->
                            {{#scopes}}{{#-first}}if{{/-first}}{{^-first}} else if{{/-first}} (!principal.scopes().contains("{{scope}}")) {
                                CompletableFuture.failedFuture(HttpServerResponseException.of(403, "Forbidden"))
                            }{{/scopes}} else {
                                CompletableFuture.completedFuture(principal)
                            }
                        }{{/vendorExtensions.hasScopes}}{{/isOAuth}}

                {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}.whenComplete { {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal, {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error ->
                    if ({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error != null) {
                        future.completeExceptionally({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error)
                    } else if ({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal != null) {
                        future.complete({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal)
                    } else {
                {{#vendorExtensions.isLast}}
                        future.completeExceptionally(HttpServerResponseException.of(403, "Forbidden"))
                {{/vendorExtensions.isLast}}
                {{/lambda.indented}}{{/vendorExtensions.isFirst}}{{/methods}}
                {{#methods}}
                        }
                    }
            {{/methods}}

            return future.thenCompose { principal ->
                if (principal == null) {
                    CompletableFuture.failedFuture(HttpServerResponseException.of(403, "Forbidden"));
                } else {
                    Principal.set(ctx, principal)
                    try {
                        chain.process(ctx, request)
                    } catch (e: Exception) {
                        CompletableFuture.failedFuture(e)
                    }
                }
            }
        }
    }

    @Tag({{name}}::class)
    @DefaultComponent
    fun {{#lambda.camelcase}}{{name}}HttpServerAuthInterceptor{{/lambda.camelcase}}({{#methods}}
      @Tag(ApiSecurity.{{#lambda.classname}}{{name}}{{/lambda.classname}}::class) {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}: HttpServerPrincipalExtractor<{{#isOAuth}}PrincipalWithScopes{{/isOAuth}}{{^isOAuth}}Principal{{/isOAuth}}>{{^vendorExtensions.isLast}},
      {{/vendorExtensions.isLast}}{{/methods}}): {{name}}HttpServerInterceptor {
        return {{name}}HttpServerInterceptor({{#methods}}{{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}{{^vendorExtensions.isLast}}, {{/vendorExtensions.isLast}}{{/methods}})
    }

{{/vendorExtensions.authMethods}}

}
