/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) ({{{generatorVersion}}}).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package {{apiPackage}}

import java.util.function.Function;

import ru.tinkoff.kora.common.Context
import ru.tinkoff.kora.common.Module
import ru.tinkoff.kora.common.Tag
import ru.tinkoff.kora.common.DefaultComponent
import ru.tinkoff.kora.common.Principal
import ru.tinkoff.kora.config.common.extractor.ConfigValueExtractor
import ru.tinkoff.kora.config.common.Config
import ru.tinkoff.kora.http.server.common.HttpServerInterceptor
import ru.tinkoff.kora.http.server.common.HttpServerInterceptor.InterceptChain;
import ru.tinkoff.kora.http.server.common.HttpServerRequest
import ru.tinkoff.kora.http.server.common.HttpServerResponse
import ru.tinkoff.kora.http.server.common.HttpServerResponseException
import java.util.concurrent.CompletionStage
import java.util.concurrent.CompletableFuture
import java.util.concurrent.CompletionException


import ru.tinkoff.kora.http.common.auth.*
import ru.tinkoff.kora.http.server.common.auth.*



@ru.tinkoff.kora.common.annotation.Generated("openapi generator kora client")
@ru.tinkoff.kora.common.Module
public interface ApiSecurity {
{{#vendorExtensions.tags}}

    class {{.}} {}
{{/vendorExtensions.tags}}

{{#vendorExtensions.authMethods}}
    @ru.tinkoff.kora.common.annotation.Generated("openapi generator kora server")
    class {{name}}HttpServerInterceptor(
        {{#methods}}  @Tag(ApiSecurity.{{#lambda.classname}}{{name}}{{/lambda.classname}}::class) val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}: HttpServerPrincipalExtractor<{{#isOAuth}}PrincipalWithScopes{{/isOAuth}}{{^isOAuth}}Principal{{/isOAuth}}>{{^vendorExtensions.isLast}},
        {{/vendorExtensions.isLast}}{{/methods}}
    ) : HttpServerInterceptor {

        override fun intercept(ctx: Context, request: HttpServerRequest, chain: InterceptChain): CompletionStage<HttpServerResponse> {
            var future = CompletableFuture<Principal>(){{#methods}}{{#isApiKey}}{{#isKeyInHeader}}

            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("{{keyParamName}}"){{/isKeyInHeader}}{{#isKeyInQuery}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query = request.queryParams().get("{{keyParamName}}")
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = if ({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query == null || {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query.isEmpty())
              null else {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query.iterator().next();
            {{/isKeyInQuery}}{{#isKeyInCookie}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.cookies().filter { "{{keyParamName}}" == it.name() }.map { it.value() }.firstOrNull()
            {{/isKeyInCookie}}
            {{/isApiKey}}{{#isBasicBasic}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization")
            {{/isBasicBasic}}{{#isBasicBearer}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization")
            {{/isBasicBearer}}{{#isOAuth}}
            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization")
            {{/isOAuth}}


            val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}} = this.{{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}.extract(request, {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token){{^isOAuth}}{{/isOAuth}}{{#isOAuth}}{{#vendorExtensions.hasScopes}}
              .thenApply<Principal> { principal -> {{#scopes}}
                 if (!principal.scopes().contains("{{scope}}")) throw HttpServerResponseException.of(403, "Forbidden"){{/scopes}}
                 principal
              }{{/vendorExtensions.hasScopes}}{{/isOAuth}}{{/methods}}{{#methods}}

            {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}.whenComplete { {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal, {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error ->
                if ({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error != null) { future.completeExceptionally({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_error); }
                else if ({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal != null) { future.complete({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_principal); }
                else { {{#vendorExtensions.isLast}}
                  future.completeExceptionally(HttpServerResponseException.of(403, "Forbidden"));{{/vendorExtensions.isLast}}{{^vendorExtensions.isLast}}

    {{/vendorExtensions.isLast}}
                {{/methods}}
                {{#methods}}

                }
            }
              {{/methods}}



            return future.thenCompose { principal ->
              if (principal == null) {
                throw HttpServerResponseException.of(403, "Forbidden");
              }
              Principal.set(ctx, principal);
              chain.process(ctx, request);
            };
        }
    }

    @Tag({{name}}::class)
    @DefaultComponent
    fun {{#lambda.camelcase}}{{name}}HttpServerInterceptor{{/lambda.camelcase}}({{#methods}}
      @Tag(ApiSecurity.{{#lambda.classname}}{{name}}{{/lambda.classname}}::class) {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}: HttpServerPrincipalExtractor<{{#isOAuth}}PrincipalWithScopes{{/isOAuth}}{{^isOAuth}}Principal{{/isOAuth}}>{{^vendorExtensions.isLast}},
      {{/vendorExtensions.isLast}}{{/methods}}): {{name}}HttpServerInterceptor {
        return {{name}}HttpServerInterceptor({{#methods}}{{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}{{^vendorExtensions.isLast}}, {{/vendorExtensions.isLast}}{{/methods}})
    }

{{/vendorExtensions.authMethods}}

}
