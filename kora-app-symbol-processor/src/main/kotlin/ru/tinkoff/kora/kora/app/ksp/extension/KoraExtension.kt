package ru.tinkoff.kora.kora.app.ksp.extension

import com.google.devtools.ksp.getClassDeclarationByName
import com.google.devtools.ksp.getConstructors
import com.google.devtools.ksp.isPublic
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.squareup.kotlinpoet.ClassName
import ru.tinkoff.kora.ksp.common.CommonAopUtils
import ru.tinkoff.kora.ksp.common.exception.ProcessingErrorException
import ru.tinkoff.kora.ksp.common.generatedClass
import ru.tinkoff.kora.ksp.common.generatedClassName

interface KoraExtension {
    fun getDependencyGenerator(resolver: Resolver, type: KSType, tags: Set<String>): (() -> ExtensionResult)?

    fun generatedByProcessor(resolver: Resolver, source: KSClassDeclaration, postfix: String): (() -> ExtensionResult)? {
        val generatedTypeName = source.generatedClass(postfix)
        return generatedByProcessorWithName(resolver, source, generatedTypeName)
    }

    fun generatedByProcessor(resolver: Resolver, source: KSClassDeclaration, postfix: ClassName): (() -> ExtensionResult)? {
        val generatedTypeName = source.generatedClass(postfix)
        return generatedByProcessorWithName(resolver, source, generatedTypeName)
    }


    fun generatedByProcessorWithName(resolver: Resolver, source: KSClassDeclaration, generatedTypeName: String): (() -> ExtensionResult)? {
        val packageName = source.packageName.asString()
        return ret@{
            val maybeGenerated = resolver.getClassDeclarationByName("$packageName.$generatedTypeName")
            if (maybeGenerated == null) {
                throw ProcessingErrorException("Class $packageName.$generatedTypeName was expected to be generated from element by annotation processor but was not", source)
            }
            if (!CommonAopUtils.hasAopAnnotations(maybeGenerated)) {
                if (maybeGenerated.primaryConstructor != null) {
                    return@ret ExtensionResult.fromConstructor(maybeGenerated.primaryConstructor!!, maybeGenerated)
                }
                // probably generated by java annotation processor
                val constructors = maybeGenerated.getConstructors()
                    .filter { it.isPublic() }
                    .toList()
                if (constructors.size != 1) {
                    throw ProcessingErrorException("Extension generated type with more than one constructor", maybeGenerated)
                }
                return@ret ExtensionResult.fromConstructor(constructors[0], maybeGenerated)
            }
            val aopProxy = maybeGenerated.generatedClass("_AopProxy")
            val aopProxyDecl = resolver.getClassDeclarationByName("$packageName.$aopProxy")
            if (aopProxyDecl == null) {
                throw ProcessingErrorException("Class $packageName.$generatedTypeName was expected to be generated from element by annotation processor but was not", maybeGenerated)
            }
            // probably generated by java annotation processor
            val constructors = aopProxyDecl.getConstructors()
                .filter { it.isPublic() }
                .toList()
            if (constructors.size != 1) {
                throw ProcessingErrorException("Extension generated type with more than one constructor", maybeGenerated)
            }
            return@ret ExtensionResult.fromConstructor(constructors[0], maybeGenerated)
        }
    }
}
